<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HashMaster Ultimate (Infinite Colors)</title>

    <!-- ===== å¯é€‰å¤–éƒ¨å“ˆå¸Œåº“ =====
         å°†å¯¹åº” .min.js æ–‡ä»¶æ”¾åœ¨ä¸ index.html ç›¸åŒç›®å½•å³å¯å¯ç”¨å¯¹åº”ç®—æ³•ã€‚
         æ–‡ä»¶ä¸å­˜åœ¨æ—¶è¯¥ç®—æ³•ä¸æ˜¾ç¤ºï¼Œä¸å½±å“å…¶ä»–åŠŸèƒ½ã€‚

         ä¸‹è½½åœ°å€ï¼š
           spark-md5.min.js  â†’ https://cdn.jsdelivr.net/npm/spark-md5/spark-md5.min.js
           sha3.min.js       â†’ https://cdn.jsdelivr.net/npm/js-sha3/build/sha3.min.js
           blakejs.min.js    â†’ https://cdn.jsdelivr.net/npm/blakejs/blakejs.min.js
           crypto-js.min.js  â†’ https://cdn.jsdelivr.net/npm/crypto-js/crypto-js.js  (å¦å­˜ä¸º crypto-js.min.js)
           crc32.min.js      â†’ https://cdn.jsdelivr.net/npm/crc-32/crc32.min.js
           adler32.min.js    â†’ https://cdn.jsdelivr.net/npm/adler-32/adler32.min.js
           sm-crypto.min.js  â†’ https://cdn.jsdelivr.net/npm/sm-crypto/dist/sm-crypto.min.js
    ===== -->

    <!-- MD5 â†’ window.SparkMD5 -->
    <script src="./spark-md5.min.js" onerror="console.warn('[HashMaster] spark-md5.min.js æœªæ‰¾åˆ°ï¼ŒMD5 ä¸å¯ç”¨')"></script>
    <!-- SHA3-256/512, Keccak-256 â†’ window.sha3_256, sha3_512, keccak_256 -->
    <script src="./sha3.min.js" onerror="console.warn('[HashMaster] sha3.min.js æœªæ‰¾åˆ°ï¼ŒSHA3/Keccak ä¸å¯ç”¨')"></script>
    <!-- BLAKE2b/BLAKE2s â†’ window.blakejs -->
    <script src="./blakejs.min.js" onerror="console.warn('[HashMaster] blakejs.min.js æœªæ‰¾åˆ°ï¼ŒBLAKE2 ä¸å¯ç”¨')"></script>
    <!-- RIPEMD-160, Whirlpool â†’ window.CryptoJS -->
    <script src="./crypto-js.min.js" onerror="console.warn('[HashMaster] crypto-js.min.js æœªæ‰¾åˆ°ï¼ŒRIPEMD-160/Whirlpool ä¸å¯ç”¨')"></script>
    <!-- CRC32 â†’ window.CRC32 -->
    <script src="./crc32.min.js" onerror="console.warn('[HashMaster] crc32.min.js æœªæ‰¾åˆ°ï¼ŒCRC32 ä¸å¯ç”¨')"></script>
    <!-- Adler32 â†’ window.Adler32 -->
    <script src="./adler32.min.js" onerror="console.warn('[HashMaster] adler32.min.js æœªæ‰¾åˆ°ï¼ŒAdler32 ä¸å¯ç”¨')"></script>
    <!-- SM3 â†’ window.smCrypto -->
    <script src="./sm-crypto.min.js" onerror="console.warn('[HashMaster] sm-crypto.min.js æœªæ‰¾åˆ°ï¼ŒSM3 ä¸å¯ç”¨')"></script>

    <style>
        :root {
            --primary: #4f46e5;
            --bg: #f8fafc;
            --surface: #ffffff;
            --text-main: #0f172a;
            --text-sub: #64748b;
            --border: #e2e8f0;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --match-bg: #22c55e;
            --match-text: #ffffff;
            --progress-bg: #e2e8f0;
        }

        [data-theme="dark"] {
            --primary: #6366f1;
            --bg: #0f172a;
            --surface: #1e293b;
            --text-main: #f1f5f9;
            --text-sub: #94a3b8;
            --border: #334155;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            --match-bg: #059669;
            --progress-bg: #334155;
        }

        * { box-sizing: border-box; outline: none; transition: background-color 0.3s, border-color 0.3s, color 0.3s; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: var(--bg); color: var(--text-main); padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }

        /* é¡¶éƒ¨å¯¼èˆª */
        .navbar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .brand { font-size: 1.5rem; font-weight: 800; background: linear-gradient(135deg, var(--primary), #ec4899); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .theme-toggle { background: var(--surface); border: 1px solid var(--border); width: 36px; height: 36px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: var(--shadow); }

        /* é…ç½®é¢æ¿ */
        .config-panel { background: var(--surface); padding: 20px; border-radius: 12px; border: 1px solid var(--border); box-shadow: var(--shadow); margin-bottom: 20px; }

        /* ç®—æ³•åˆ†ç±»å¸ƒå±€ */
        .algo-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed var(--border);
        }
        .algo-section-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-sub);
            margin-bottom: 2px;
        }
        .algo-cat-block {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            flex-wrap: wrap;
        }
        .algo-category {
            font-size: 10px;
            font-weight: 700;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 0.07em;
            min-width: 72px;
            flex-shrink: 0;
            padding-top: 2px;
        }
        .algo-items { display: flex; flex-wrap: wrap; gap: 8px 16px; flex: 1; }
        .checkbox-label { display: flex; align-items: center; gap: 5px; cursor: pointer; user-select: none; font-weight: 500; font-size: 13px; }
        input[type="checkbox"] { width: 14px; height: 14px; accent-color: var(--primary); cursor: pointer; }

        .toolbar { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
        .target-input { flex: 1; min-width: 200px; padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); color: var(--text-main); font-family: monospace; font-size: 13px; }
        .target-input:focus { border-color: var(--primary); }

        /* æŒ‰é’® */
        .btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 16px; border-radius: 8px; font-size: 13px; font-weight: 500; cursor: pointer; border: 1px solid transparent; transition: all 0.2s; }
        .btn-primary { background: var(--primary); color: white; border: none; box-shadow: 0 2px 4px rgba(79, 70, 229, 0.3); }
        .btn-primary:hover { opacity: 0.9; transform: translateY(-1px); }
        .btn-secondary { background: var(--bg); border-color: var(--border); color: var(--text-main); }
        .btn-secondary:hover { border-color: var(--primary); color: var(--primary); background: var(--surface); }
        .btn-danger { color: #ef4444; background: rgba(239, 68, 68, 0.05); border-color: rgba(239, 68, 68, 0.2); }
        .btn-danger:hover { background: rgba(239, 68, 68, 0.1); border-color: #ef4444; }

        /* æ‹–æ‹½åŒº */
        .upload-area { border: 2px dashed var(--border); border-radius: 12px; padding: 30px; text-align: center; background: var(--surface); cursor: pointer; margin-bottom: 20px; transition: 0.2s; }
        .upload-area:hover { border-color: var(--primary); background: rgba(79, 70, 229, 0.02); }

        /* è¡¨æ ¼ */
        .table-card { background: var(--surface); border-radius: 12px; border: 1px solid var(--border); overflow: hidden; box-shadow: var(--shadow); }
        .table-card:fullscreen,
        .table-card:-webkit-full-screen,
        .table-card:-moz-full-screen {
            overflow-y: auto;
            border-radius: 0;
            background: var(--surface);
        }
        table { width: 100%; border-collapse: collapse; }
        th { background: rgba(0,0,0,0.02); color: var(--text-sub); font-size: 0.8rem; text-transform: uppercase; padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--border); }
        td { padding: 16px; border-bottom: 1px solid var(--border); vertical-align: top; }
        tr:last-child td { border-bottom: none; }

        /* Hash å†…å®¹ */
        .hash-list { display: flex; flex-direction: column; gap: 6px; }
        .hash-row { display: flex; align-items: center; gap: 10px; font-size: 13px; }
        .algo-tag { width: 85px; font-weight: 600; color: var(--text-sub); font-size: 11px; text-align: right; flex-shrink: 0; }
        .hash-val { font-family: monospace; word-break: break-all; color: var(--text-main); flex: 1; font-size: 12px; }
        .btn-copy-mini { opacity: 0; padding: 2px 6px; font-size: 10px; border: 1px solid var(--border); background: var(--surface); border-radius: 4px; cursor: pointer; color: var(--text-sub); }
        .hash-row:hover .btn-copy-mini { opacity: 1; }

        /* é«˜äº®æ ‡è®° */
        .group-id-badge {
            font-size: 10px; padding: 1px 6px; border-radius: 10px; margin-right: 8px;
            font-weight: bold; border: 1px solid; display: inline-block;
        }

        /* ç›®æ ‡åŒ¹é…é«˜äº® (ä¼˜å…ˆçº§æœ€é«˜) */
        .target-match-span { background-color: var(--match-bg); color: var(--match-text); padding: 1px 4px; border-radius: 3px; }
        .row-target-matched { background-color: rgba(34, 197, 94, 0.1) !important; box-shadow: inset 4px 0 0 var(--match-bg) !important; }

        .progress-bar { width: 100%; height: 4px; background: var(--progress-bg); border-radius: 2px; margin-top: 8px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.1s linear; }

        .toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(50px); background: #1e293b; color: white; padding: 10px 24px; border-radius: 30px; opacity: 0; transition: 0.3s; z-index: 999; pointer-events: none; }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
    </style>
</head>
<body>

<div class="container">
    <nav class="navbar">
        <div class="brand">âš¡ HashMaster Ultimate v8</div>
        <button class="theme-toggle" onclick="toggleTheme()" title="åˆ‡æ¢ä¸»é¢˜">ğŸŒ“</button>
    </nav>

    <div class="config-panel">
        <div class="algo-group" id="algoGroup">
            <span class="algo-section-title">ç®—æ³•:</span>
            <!-- å¤é€‰æ¡†ç”± initAlgoCheckboxes() åŠ¨æ€ç”Ÿæˆ -->
        </div>

        <div class="toolbar">
            <input type="text" id="targetHash" class="target-input" placeholder="ğŸ¯ ç²˜è´´ Hash å€¼è‡ªåŠ¨æŸ¥æ‰¾..." oninput="checkMatches()">
            <button class="btn btn-secondary" onclick="copyAllHashes()">ğŸ“‹ å¤åˆ¶å…¨éƒ¨</button>
            <button class="btn btn-secondary" onclick="exportCSV()">ğŸ“¥ å¯¼å‡º CSV</button>
            <button class="btn btn-secondary" onclick="toggleFullscreen()" id="fullscreenBtn">â›¶ å…¨å±</button>
            <button class="btn btn-danger" onclick="clearAll()">ğŸ—‘ï¸ æ¸…ç©º</button>
        </div>
    </div>

    <div class="upload-area" id="dropZone">
        <p style="margin:0 0 8px 0; font-size:1.1rem;">ç‚¹å‡»æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°è¿™é‡Œ</p>
        <p style="margin:0; color:var(--text-sub); font-size:0.9rem;">æ”¯æŒæ— é™é¢œè‰²åˆ†ç»„ | æœ¬åœ°å®‰å…¨è®¡ç®—</p>
        <button class="btn btn-primary" style="margin-top:15px;" onclick="document.getElementById('fileInput').click()">é€‰æ‹©æ–‡ä»¶</button>
        <input type="file" id="fileInput" multiple style="display:none">
    </div>

    <div class="table-card" id="tableCard">
        <table id="hashTable">
            <thead>
                <tr>
                    <th width="30%">æ–‡ä»¶å</th>
                    <th width="10%">å¤§å°</th>
                    <th width="60%">è®¡ç®—ç»“æœ</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
</div>

<div id="toast" class="toast"></div>

<script>
    // ============================================================
    // å·¥å…·å‡½æ•°
    // ============================================================
    function bufToHex(arrayBuffer) {
        return Array.from(new Uint8Array(arrayBuffer))
            .map(b => b.toString(16).padStart(2, '0')).join('');
    }
    function isLibAvailable(globalName) {
        return typeof window[globalName] !== 'undefined';
    }
    function getAvailableAlgoConfigs() {
        return ALGO_CONFIGS.filter(cfg => cfg.available());
    }
    // CryptoJS WordArray å…¼å®¹æ„å»ºï¼ˆæ”¯æŒæ‰€æœ‰ CryptoJS ç‰ˆæœ¬ï¼‰
    function toWordArray(u8arr) {
        const words = [];
        for (let i = 0; i < u8arr.length; i++) {
            words[i >>> 2] |= u8arr[i] << (24 - (i % 4) * 8);
        }
        return CryptoJS.lib.WordArray.create(words, u8arr.length);
    }

    // ============================================================
    // ç®—æ³•é…ç½®è¡¨
    // æ–°å¢ç®—æ³•ï¼šåœ¨æ­¤è¿½åŠ ä¸€æ¡è®°å½•å³å¯ï¼Œæ— éœ€ä¿®æ”¹å…¶ä»–ä»£ç 
    //   category : åˆ†ç±»åï¼ˆç”¨äº UI åˆ†ç»„ï¼‰
    //   label    : æ˜¾ç¤ºåç§°
    //   value    : ç®—æ³• IDï¼ˆitem.results çš„é”®ï¼‰
    //   defaultOn: é»˜è®¤æ˜¯å¦é€‰ä¸­ï¼ˆå·²å…¨éƒ¨è®¾ä¸º falseï¼Œç”±ç”¨æˆ·è‡ªé€‰ï¼‰
    //   available: è¿”å› true è¡¨ç¤ºå¯¹åº”åº“å·²åŠ è½½
    //   compute  : æ¥æ”¶ ArrayBufferï¼Œè¿”å› hex å­—ç¬¦ä¸²ï¼ˆæ”¯æŒåŒæ­¥/å¼‚æ­¥ï¼‰
    // ============================================================
    const ALGO_CONFIGS = [

        // ----- SHA æ ‡å‡†ï¼ˆWeb Crypto API å†…ç½®ï¼Œå§‹ç»ˆå¯ç”¨ï¼‰-----
        { category:'SHA æ ‡å‡†', label:'SHA-1',   value:'SHA-1',   defaultOn:false, available:()=>true,
          compute: async b => bufToHex(await crypto.subtle.digest('SHA-1', b)) },
        { category:'SHA æ ‡å‡†', label:'SHA-256', value:'SHA-256', defaultOn:false, available:()=>true,
          compute: async b => bufToHex(await crypto.subtle.digest('SHA-256', b)) },
        { category:'SHA æ ‡å‡†', label:'SHA-384', value:'SHA-384', defaultOn:false, available:()=>true,
          compute: async b => bufToHex(await crypto.subtle.digest('SHA-384', b)) },
        { category:'SHA æ ‡å‡†', label:'SHA-512', value:'SHA-512', defaultOn:false, available:()=>true,
          compute: async b => bufToHex(await crypto.subtle.digest('SHA-512', b)) },

        // ----- SHA-3 ç³»åˆ—ï¼ˆéœ€ sha3.min.jsï¼‰-----
        { category:'SHA-3', label:'SHA3-256', value:'SHA3-256', defaultOn:false,
          available: () => isLibAvailable('sha3_256'),
          compute: b => sha3_256(new Uint8Array(b)) },
        { category:'SHA-3', label:'SHA3-512', value:'SHA3-512', defaultOn:false,
          available: () => isLibAvailable('sha3_512'),
          compute: b => sha3_512(new Uint8Array(b)) },

        // ----- ä¼ ç»Ÿå“ˆå¸Œ -----
        // éœ€ spark-md5.min.js â†’ window.SparkMD5
        { category:'ä¼ ç»Ÿå“ˆå¸Œ', label:'MD5', value:'MD5', defaultOn:false,
          available: () => isLibAvailable('SparkMD5'),
          compute: b => SparkMD5.ArrayBuffer.hash(b) },
        // éœ€ crypto-js.min.js â†’ window.CryptoJS
        { category:'ä¼ ç»Ÿå“ˆå¸Œ', label:'RIPEMD-160', value:'RIPEMD-160', defaultOn:false,
          available: () => isLibAvailable('CryptoJS') && !!CryptoJS.RIPEMD160,
          compute: b => CryptoJS.RIPEMD160(toWordArray(new Uint8Array(b))).toString() },

        // ----- ç°ä»£å“ˆå¸Œ -----
        // éœ€ blakejs.min.js â†’ window.blakejs
        { category:'ç°ä»£å“ˆå¸Œ', label:'BLAKE2b-512', value:'BLAKE2b', defaultOn:false,
          available: () => isLibAvailable('blakejs'),
          compute: b => blakejs.blake2bHex(new Uint8Array(b), null, 64) },
        { category:'ç°ä»£å“ˆå¸Œ', label:'BLAKE2s-256', value:'BLAKE2s', defaultOn:false,
          available: () => isLibAvailable('blakejs'),
          compute: b => blakejs.blake2sHex(new Uint8Array(b), null, 32) },
        // éœ€ sha3.min.js â†’ window.keccak_256
        { category:'ç°ä»£å“ˆå¸Œ', label:'Keccak-256', value:'Keccak-256', defaultOn:false,
          available: () => isLibAvailable('keccak_256'),
          compute: b => keccak_256(new Uint8Array(b)) },
        // éœ€ sm-crypto.min.js â†’ window.smCrypto
        { category:'ç°ä»£å“ˆå¸Œ', label:'SM3', value:'SM3', defaultOn:false,
          available: () => isLibAvailable('smCrypto') && typeof smCrypto.sm3 === 'function',
          compute: b => {
              const hex = Array.from(new Uint8Array(b)).map(x => x.toString(16).padStart(2,'0')).join('');
              return smCrypto.sm3(hex);
          }},

        // ----- æ ¡éªŒå’Œ -----
        // éœ€ crc32.min.js â†’ window.CRC32
        { category:'æ ¡éªŒå’Œ', label:'CRC32', value:'CRC32', defaultOn:false,
          available: () => isLibAvailable('CRC32'),
          compute: b => (CRC32.buf(new Uint8Array(b)) >>> 0).toString(16).padStart(8, '0') },
        // CRC16-Modbusï¼ˆå†…ç½®ï¼Œæ— éœ€å¤–éƒ¨åº“ï¼‰
        { category:'æ ¡éªŒå’Œ', label:'CRC16', value:'CRC16', defaultOn:false, available: () => true,
          compute: b => {
              const d = new Uint8Array(b); let c = 0xFFFF;
              for (let i = 0; i < d.length; i++) {
                  c ^= d[i];
                  for (let j = 0; j < 8; j++) c = (c & 1) ? (c >>> 1) ^ 0xA001 : (c >>> 1);
              }
              return c.toString(16).padStart(4, '0');
          }},
        // éœ€ adler32.min.js â†’ window.Adler32
        { category:'æ ¡éªŒå’Œ', label:'Adler32', value:'Adler32', defaultOn:false,
          available: () => isLibAvailable('Adler32'),
          compute: b => (Adler32.buf(new Uint8Array(b)) >>> 0).toString(16).padStart(8, '0') },
        // éœ€ crypto-js.min.js â†’ window.CryptoJS.algo.Whirlpool
        { category:'æ ¡éªŒå’Œ', label:'Whirlpool', value:'Whirlpool', defaultOn:false,
          available: () => isLibAvailable('CryptoJS') && !!(CryptoJS.algo && CryptoJS.algo.Whirlpool),
          compute: b => CryptoJS.algo.Whirlpool.create().finalize(toWordArray(new Uint8Array(b))).toString() },
    ];

    // ç»Ÿä¸€å“ˆå¸Œè®¡ç®—å…¥å£ï¼ˆå…¼å®¹åŒæ­¥/å¼‚æ­¥ compute å‡½æ•°ï¼‰
    async function computeHash(algoValue, arrayBuffer) {
        const cfg = ALGO_CONFIGS.find(c => c.value === algoValue);
        if (!cfg) throw new Error('æœªçŸ¥ç®—æ³•: ' + algoValue);
        return Promise.resolve(cfg.compute(arrayBuffer));
    }

    // åŠ¨æ€ç”Ÿæˆç®—æ³•å¤é€‰æ¡†ï¼ˆå¸¦åˆ†ç±»ï¼‰
    function initAlgoCheckboxes() {
        const algoGroup = document.getElementById('algoGroup');
        const titleEl = algoGroup.querySelector('.algo-section-title');
        algoGroup.innerHTML = '';
        if (titleEl) algoGroup.appendChild(titleEl);

        const available = getAvailableAlgoConfigs();
        const categories = [...new Set(available.map(c => c.category))];

        categories.forEach(cat => {
            const block = document.createElement('div');
            block.className = 'algo-cat-block';

            const catLabel = document.createElement('span');
            catLabel.className = 'algo-category';
            catLabel.textContent = cat;
            block.appendChild(catLabel);

            const items = document.createElement('div');
            items.className = 'algo-items';

            available.filter(c => c.category === cat).forEach(cfg => {
                const lbl = document.createElement('label');
                lbl.className = 'checkbox-label';
                const cb = document.createElement('input');
                cb.type = 'checkbox'; cb.value = cfg.value; cb.checked = cfg.defaultOn;
                cb.addEventListener('change', handleConfigChange);
                lbl.appendChild(cb);
                lbl.appendChild(document.createTextNode(' ' + cfg.label));
                items.appendChild(lbl);
            });

            block.appendChild(items);
            algoGroup.appendChild(block);
        });
    }

    // ç»“æœçª—å£å…¨å±åˆ‡æ¢
    function toggleFullscreen() {
        const el = document.getElementById('tableCard');
        if (!document.fullscreenElement) {
            el.requestFullscreen && el.requestFullscreen().catch(() => showToast('å…¨å±ä¸å¯ç”¨'));
        } else {
            document.exitFullscreen && document.exitFullscreen();
        }
    }
    document.addEventListener('fullscreenchange', () => {
        const btn = document.getElementById('fullscreenBtn');
        if (btn) btn.textContent = document.fullscreenElement ? 'âœ• é€€å‡ºå…¨å±' : 'â›¶ å…¨å±';
    });

    // ============================================================
    // åŸæœ‰ä»£ç ï¼ˆä¿æŒä¸å˜ï¼‰
    // ============================================================
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const tableBody = document.getElementById('tableBody');
    const targetInput = document.getElementById('targetHash');

    let filesMap = new Map();
    let isDarkMode = false;

    // --- ä¸»é¢˜æ§åˆ¶ ---
    function toggleTheme() {
        const html = document.documentElement;
        const current = html.getAttribute('data-theme');
        const next = current === 'dark' ? 'light' : 'dark';
        html.setAttribute('data-theme', next);
        isDarkMode = (next === 'dark');
        highlightAndMatch();
    }

    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.setAttribute('data-theme', 'dark');
        isDarkMode = true;
    }

    // --- äº‹ä»¶ç›‘å¬ ---
    fileInput.addEventListener('change', function() { handleFiles(this.files); this.value = ''; });
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.borderColor = 'var(--primary)'; });
    dropZone.addEventListener('dragleave', () => dropZone.style.borderColor = 'var(--border)');
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.style.borderColor = 'var(--border)'; handleFiles(e.dataTransfer.files); });

    // --- æ ¸å¿ƒé€»è¾‘ ---
    function getActiveAlgos() {
        return Array.from(document.querySelectorAll('.algo-group input:checked')).map(cb => cb.value);
    }

    function handleFiles(files) {
        if (!files.length) return;
        Array.from(files).forEach(file => {
            const id = Math.random().toString(36).substr(2, 9);
            filesMap.set(id, { id, file, results: {}, progress: 0, status: 'pending' });
        });
        renderTable();
        processQueue();
    }

    async function processQueue() {
        const activeAlgos = getActiveAlgos();

        for (let [id, item] of filesMap) {
            const allDone = activeAlgos.every(algo => item.results[algo]);
            if (allDone) continue;

            item.status = 'reading';
            updateRow(item);

            try {
                const arrayBuffer = await readFileWithProgress(item.file, (pct) => {
                    item.progress = pct;
                    requestAnimationFrame(() => updateRow(item));
                });

                item.status = 'computing';
                item.progress = 100;
                updateRow(item);

                const tasks = activeAlgos.map(async (algo) => {
                    if (item.results[algo]) return;
                    item.results[algo] = await computeHash(algo, arrayBuffer);
                });

                await Promise.all(tasks);
                item.status = 'done';

            } catch (err) {
                console.error(err);
                item.status = 'error';
            }
            updateRow(item);
            highlightAndMatch();
        }
    }

    // --- é¢œè‰²ç”Ÿæˆç®—æ³• (æ ¸å¿ƒæ”¹è¿›) ---
    function generateDynamicColor(index) {
        const goldenAngle = 137.508;
        const hue = (index * goldenAngle) % 360;

        if (isDarkMode) {
            return {
                bg: `hsla(${hue}, 60%, 20%, 0.3)`,
                border: `hsl(${hue}, 70%, 60%)`,
                badge: `hsl(${hue}, 70%, 80%)`
            };
        } else {
            return {
                bg: `hsla(${hue}, 80%, 92%, 0.6)`,
                border: `hsl(${hue}, 70%, 45%)`,
                badge: `hsl(${hue}, 80%, 30%)`
            };
        }
    }

    // --- æ¸²æŸ“é€»è¾‘ ---
    function renderTable() {
        tableBody.innerHTML = '';
        if (filesMap.size === 0) {
            tableBody.innerHTML = '<tr><td colspan="3" style="text-align:center; padding:40px; color:var(--text-sub)">æš‚æ— æ–‡ä»¶</td></tr>';
            return;
        }
        filesMap.forEach(item => {
            const tr = document.createElement('tr');
            tr.id = `row-${item.id}`;
            tableBody.appendChild(tr);
            updateRow(item);
        });
        highlightAndMatch();
    }

    function updateRow(item) {
        const tr = document.getElementById(`row-${item.id}`);
        if (!tr) return;

        let contentHtml = '';
        const activeAlgos = getActiveAlgos();

        if (item.status === 'done' || (item.status === 'computing' && Object.keys(item.results).length > 0)) {
            contentHtml = `<div class="hash-list">`;
            activeAlgos.forEach(algo => {
                const val = item.results[algo] || '...';
                contentHtml += `
                    <div class="hash-row">
                        <span class="algo-tag">${algo}</span>
                        <span class="hash-val" id="hash-${item.id}-${algo}">${val}</span>
                        <button class="btn-copy-mini" onclick="copyText('${val}')">å¤åˆ¶</button>
                    </div>`;
            });
            contentHtml += `</div>
                <div style="margin-top:8px; text-align:right;">
                     <button class="btn btn-danger" style="font-size:11px; padding:2px 8px;" onclick="removeFile('${item.id}')">åˆ é™¤æ­¤è¡Œ</button>
                </div>`;
        } else if (item.status === 'reading' || item.status === 'computing') {
            contentHtml = `
                <div style="color:var(--text-sub); font-size:12px; margin-bottom:4px;">
                    ${item.status === 'reading' ? 'è¯»å–ä¸­' : 'è®¡ç®—ä¸­'} ${Math.round(item.progress)}%
                </div>
                <div class="progress-bar"><div class="progress-fill" style="width:${item.progress}%"></div></div>`;
        } else if (item.status === 'error') {
            contentHtml = `<span style="color:#ef4444">å¤±è´¥</span> <button class="btn btn-danger" onclick="removeFile('${item.id}')">åˆ é™¤</button>`;
        } else {
            contentHtml = `<span style="color:var(--text-sub)">ç­‰å¾…ä¸­...</span>`;
        }

        tr.innerHTML = `
            <td>
                <div style="display:flex; align-items:center;">
                    <span id="badge-${item.id}" class="group-id-badge" style="display:none;"></span>
                    <div style="font-weight:600; color:var(--text-main);">${item.file.name}</div>
                </div>
            </td>
            <td style="color:var(--text-sub); font-size:13px;">${formatSize(item.file.size)}</td>
            <td>${contentHtml}</td>
        `;
    }

    // --- é«˜äº®é€»è¾‘ (æ— é™é¢œè‰²) ---
    function highlightAndMatch() {
        const target = targetInput.value.trim().toLowerCase();
        const activeAlgos = getActiveAlgos();
        const primaryAlgo = activeAlgos[0];

        const hashToGroupIndex = {};
        let groupCounter = 0;

        const hashCounts = {};
        filesMap.forEach(item => {
            if (item.status === 'done' && primaryAlgo && item.results[primaryAlgo]) {
                const h = item.results[primaryAlgo];
                hashCounts[h] = (hashCounts[h] || 0) + 1;
            }
        });

        for (let h in hashCounts) {
            if (hashCounts[h] > 1) hashToGroupIndex[h] = groupCounter++;
        }

        filesMap.forEach(item => {
            const tr = document.getElementById(`row-${item.id}`);
            const badge = document.getElementById(`badge-${item.id}`);
            if (!tr) return;

            tr.style.backgroundColor = '';
            tr.style.boxShadow = '';
            tr.classList.remove('row-target-matched');
            if (badge) badge.style.display = 'none';
            tr.querySelectorAll('.target-match-span').forEach(el => {
                el.outerHTML = el.innerText;
            });

            let isTargetMatched = false;
            if (target) {
                for (const [algo, hash] of Object.entries(item.results)) {
                    if (hash === target) {
                        isTargetMatched = true;
                        const hashSpan = document.getElementById(`hash-${item.id}-${algo}`);
                        if (hashSpan) hashSpan.innerHTML = `<span class="target-match-span">${hash}</span>`;
                    }
                }
            }

            if (isTargetMatched) {
                tr.classList.add('row-target-matched');
                return;
            }

            if (item.status === 'done' && primaryAlgo && item.results[primaryAlgo]) {
                const currentHash = item.results[primaryAlgo];
                if (hashToGroupIndex.hasOwnProperty(currentHash)) {
                    const groupIdx = hashToGroupIndex[currentHash];
                    const style = generateDynamicColor(groupIdx);
                    tr.style.backgroundColor = style.bg;
                    tr.style.boxShadow = `inset 4px 0 0 ${style.border}`;
                    if (badge) {
                        badge.style.display = 'inline-block';
                        badge.innerText = `#${groupIdx + 1}`;
                        badge.style.color = style.border;
                        badge.style.borderColor = style.border;
                        badge.style.backgroundColor = 'rgba(255,255,255,0.4)';
                    }
                }
            }
        });
    }

    // --- å·¥å…·å‡½æ•° ---
    function readFileWithProgress(file, onProgress) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onprogress = (e) => { if(e.lengthComputable) onProgress((e.loaded/e.total)*100); };
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });
    }

    function copyAllHashes() {
        if (filesMap.size === 0) return showToast('åˆ—è¡¨ä¸ºç©º');
        let text = "";
        const activeAlgos = getActiveAlgos();
        filesMap.forEach(item => {
            if (item.status === 'done') {
                text += `File: ${item.file.name}\n`;
                activeAlgos.forEach(algo => { text += `${algo}: ${item.results[algo]}\n`; });
                text += "---\n";
            }
        });
        navigator.clipboard.writeText(text).then(() => showToast('å·²å¤åˆ¶å…¨éƒ¨'));
    }

    function exportCSV() {
        if (filesMap.size === 0) return showToast('æ— æ•°æ®');
        const algos = getActiveAlgos();
        let csv = `\uFEFFæ–‡ä»¶å,å¤§å°,${algos.join(',')}\n`;
        filesMap.forEach(item => {
            if (item.status === 'done') {
                let row = `"${item.file.name}",${item.file.size}`;
                algos.forEach(algo => row += `,${item.results[algo] || ''}`);
                csv += row + "\n";
            }
        });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(new Blob([csv], {type:'text/csv'}));
        a.download = `Hash_Report_${Date.now()}.csv`;
        a.click();
    }

    function showToast(msg) {
        const t = document.getElementById('toast');
        t.textContent = msg; t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2000);
    }

    function handleConfigChange() { renderTable(); processQueue(); }
    function checkMatches() { highlightAndMatch(); }
    function removeFile(id) { filesMap.delete(id); renderTable(); }
    function clearAll() { filesMap.clear(); renderTable(); targetInput.value=''; showToast('å·²æ¸…ç©º'); }
    function copyText(t) { if(t==='...')return; navigator.clipboard.writeText(t).then(()=>showToast('å·²å¤åˆ¶')); }
    function formatSize(b) { if(!b) return '0 B'; const i = Math.floor(Math.log(b)/Math.log(1024)); return (b/Math.pow(1024,i)).toFixed(2)+' '+['B','KB','MB','GB','TB'][i]; }

    // --- é¡µé¢åˆå§‹åŒ– ---
    initAlgoCheckboxes();
</script>

</body>
</html>
